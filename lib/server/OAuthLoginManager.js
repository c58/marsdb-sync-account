import fs from 'fs';
import path from 'path';
import invariant from 'invariant';
import { method } from 'marsdb-sync-server';
import { Random } from 'marsdb';
import passport from 'passport';


// Internals
const _urlPrefix = '/_auth/oauth';
const _popupResponseTemplate = fs.readFileSync(
  path.join(__dirname, '..', '..', 'resources', 'end_of_popup_response.html')
).toString();

/**
 * OAuth login manager. It uses Passport.js for passing OAuth
 * auth process and wraps any kind of Passport.js OAuth strategy.
 * It can be used for browser-style authentication (with popup, for example),
 * or for authenticating some accessToken for a provider (given by native
 * mobile SDKs, for example).
 */
export default class OAuthLoginManager {
  constructor(accManager, middlewareApp, rootUrl) {
    this._accManager = accManager;
    this._rootUrl = rootUrl;
    this._credentials = {};
    this._providerOpts = {};

    method(`${_urlPrefix}/secret/login`, this._handleSecretLogin);
    method(`${_urlPrefix}/token/login`, this._handleTokenLogin);
    middlewareApp.get(`${_urlPrefix}/popup/:provider/callback`,
      this._handleGETPopupCallback);
    middlewareApp.get(`${_urlPrefix}/popup/:provider/:credentialToken`,
      this._handleGETPopup);
  }

  /**
   * Adds Passport.OAuth strategy by given provider name and
   * strategy generator function. The function will be called with
   * callbackURL and callback function arguments to pass to a strategy
   * object.
   * If provider with given name already registered it rises an exception.
   * @param {String}   provider
   * @param {Function} strategyCreatorFn
   */
  addStrategy(provider, strategyCreatorFn, options = {}) {
    invariant(
      !this._providerOpts[provider],
      'Provider with name "%s" already exists',
      provider
    );

    this._providerOpts[provider] = options;
    const cbUrlPrefix = `${this._rootUrl}${_urlPrefix}`;
    const callbackUrl = `${cbUrlPrefix}/popup/${provider}/callback`;
    const callback = this._handleOAuthLogin;
    const strategy = strategyCreatorFn(callbackUrl, callback);
    passport.use(provider, strategy);
  }

  /**
   * Authorize connection with given OAuth profile.
   * Create new user if connection is not authorized with some user,
   * otherwise attaches profile to currently authorized user.
   * In any case authorize connection.
   * @param  {Context} ctx
   * @param  {Object}  profile
   * @return {Promise}
   */
  _authorizeOAuth(ctx, profile) {
    if (ctx.data.userId) {
      const userId = ctx.data.userId;
      return this._accManager.addServiceToUser(userId, profile).then(() =>
        this._accManager.authConnection(ctx.connection, userId)
      );
    } else {
      return this._accManager.getOrCreateAccByProfile(profile).then(user =>
        this._accManager.authConnection(ctx.connection, user._id)
      );
    }
  }

  /**
   * Login user with given credential token and secret. The secret
   * comes to a client from popup, generated by `_handleGETPopupCallback`
   * method. If no credential token with given secret found then
   * it rises an exception. Otherwise it returns a promise that will be
   * resolved with object with `userId`, `token` and `expires` fields.
   * @param  {Object} ctx
   * @param  {String} credentialToken
   * @param  {String} secret
   * @return {Promise}
   */
  _handleSecretLogin = (ctx, credentialToken, secret) => {
    const credential = this._credentials[credentialToken];
    delete this._credentials[credentialToken];

    if (credential && credential.credentialSecret === secret) {
      const profile = credential.profile;
      return this._authorizeOAuth(ctx, profile);
    } else {
      throw new Error('No credential found with given token');
    }
  };

  /**
   * Login user with given accessToken for given provider.
   * If no provider with given name exists it reses an exception.
   * Returns a promise that will be resolved when will be successfully
   * authenticated. Resolved object consists of `userId`, `token` and `expores`
   * fields.
   * @param  {Object} ctx
   * @param  {String} provider
   * @param  {String} accessToken
   * @return {Promise}
   */
  _handleTokenLogin = (ctx, provider, accessToken) => {
    invariant(
      this._providerOpts[provider],
      'Provider %s is not supported',
      provider
    );

    const reqMock = {query: {access_token: accessToken}};
    return new Promise((resolve, reject) => {
      passport.authenticate(provider, (err, profile, info) => {
        if (!err && profile) {
          resolve(this._authorizeOAuth(ctx, profile));
        } else {
          reject(err);
        }
      })(reqMock, {});
    });
  };

  /**
   * Just done with profile
   * @param  {String}   accessToken
   * @param  {String}   refreshToken
   * @param  {Object}   profile
   * @param  {Function} done
   */
  _handleOAuthLogin = (accessToken, refreshToken, profile, done) => {
    delete profile._raw;
    done(null, profile);
  };

  /**
   * Creates Base64 encoded credentialToken for sending it
   * as a `state` field of an OAuth request and invoke
   * passport.authenticate for given provider.
   * If no provider with given name registered then it rises
   * an exception
   * @param  {Requrst}  req
   * @param  {Response} res
   * @param  {Function} next
   */
  _handleGETPopup = (req, res, next) => {
    const { provider, credentialToken } = req.params;
    invariant(
      this._providerOpts[provider],
      'Provider %s is not supported',
      provider
    );

    const b64Token = new Buffer(credentialToken).toString('base64');
    const options = {
      ...this._providerOpts[provider],
      session: false,
      state: b64Token,
    };

    passport.authenticate(provider, options)(req, res, next);
  };

  /**
   * Handle return from OAuth service to our callback.
   * If no errors then credentialToken will be set with
   * gotten user id for authenticating the connection.
   * If no authentication of the connection happened after 5sec,
   * then credential will be removed.
   * In any case send an HTML page for setting credential info
   * (credential secret) in the parent window.
   * @param  {Request}   req
   * @param  {Response}  res
   * @param  {Function}  next
   */
  _handleGETPopupCallback = (req, res, next) => {
    const provider = req.params.provider;
    const credentialToken = new Buffer(req.query.state, 'base64')
      .toString('binary');

    passport.authenticate(provider, (err, profile, info) => {
      const config = {};
      if (!err && profile && credentialToken) {
        const credentialSecret = Random.default().id(20);
        config.setCredentialToken = true;
        config.credentialSecret = credentialSecret;
        config.credentialToken = credentialToken;

        this._credentials[credentialToken] = { credentialSecret, profile };
        setTimeout(() => delete this._credentials[credentialToken], 5000);
      }

      const tplWithConfig = _popupResponseTemplate.replace(
        '##CONFIG##', JSON.stringify(config)
      );

      res.writeHead(200, {'Content-Type': 'text/html'});
      res.write(tplWithConfig);
      res.end();
    })(req, res, next);
  };
}
